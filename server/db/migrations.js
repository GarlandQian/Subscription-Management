const Database = require('better-sqlite3');
const path = require('path');
const fs = require('fs');

class DatabaseMigrations {
  constructor(dbPath) {
    this.dbPath = dbPath;
    this.db = new Database(dbPath);
    this.migrations = [
      {
        version: 1,
        name: 'initial_schema_consolidated',
        up: () => this.migration_001_initial_schema_consolidated()
      },
      {
        version: 2,
        name: 'add_notification_system',
        up: () => this.migration_002_add_notification_system()
      },
      {
        version: 3,
        name: 'add_scheduler_settings',
        up: () => this.migration_003_add_scheduler_settings()
      },
      {
        version: 4,
        name: 'add_repeat_notification_setting',
        up: () => this.migration_004_add_repeat_notification_setting()
      }
    ];
  }

  // Initialize migrations table
  initMigrationsTable() {
    this.db.exec(`
      CREATE TABLE IF NOT EXISTS migrations (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        version INTEGER NOT NULL UNIQUE,
        name TEXT NOT NULL,
        executed_at DATETIME DEFAULT CURRENT_TIMESTAMP
      )
    `);
  }

  // Get current database version
  getCurrentVersion() {
    try {
      const result = this.db.prepare('SELECT MAX(version) as version FROM migrations').get();
      return result.version || 0;
    } catch (error) {
      return 0;
    }
  }

  // Run all pending migrations
  async runMigrations() {
    console.log('üîÑ Checking for database migrations...');

    // Set database pragmas first (outside transaction)
    console.log('üìù Setting database pragmas...');
    this.db.pragma('foreign_keys = ON');

    this.initMigrationsTable();
    const currentVersion = this.getCurrentVersion();

    console.log(`üìä Current database version: ${currentVersion}`);

    const pendingMigrations = this.migrations.filter(m => m.version > currentVersion);

    if (pendingMigrations.length === 0) {
      console.log('‚úÖ Database is up to date');
      return;
    }

    console.log(`üîÑ Running ${pendingMigrations.length} pending migration(s)...`);

    for (const migration of pendingMigrations) {
      try {
        console.log(`‚è≥ Running migration ${migration.version}: ${migration.name}`);

        // Run migration in transaction
        this.db.transaction(() => {
          migration.up();
          this.db.prepare('INSERT INTO migrations (version, name) VALUES (?, ?)').run(migration.version, migration.name);
        })();

        console.log(`‚úÖ Migration ${migration.version} completed`);
      } catch (error) {
        console.error(`‚ùå Migration ${migration.version} failed:`, error);
        throw error;
      }
    }

    console.log('üéâ All migrations completed successfully!');
  }

  // Migration 001: Consolidated initial schema - Create all tables and data
  migration_001_initial_schema_consolidated() {
    console.log('üìù Creating consolidated database schema from schema.sql...');

    try {
      // Read and execute the schema.sql file
      const schemaPath = path.join(__dirname, 'schema.sql');
      const schemaSQL = fs.readFileSync(schemaPath, 'utf8');

      // Remove comments and PRAGMA statements
      const cleanSQL = schemaSQL
        .split('\n')
        .filter(line => !line.trim().startsWith('--') && !line.trim().startsWith('PRAGMA'))
        .join('\n');

      // Split into statements more carefully, handling multi-line statements
      const statements = this.parseSQL(cleanSQL);

      for (const statement of statements) {
        if (statement.trim()) {
          try {
            this.db.exec(statement);
          } catch (error) {
            // Log the problematic statement for debugging
            console.error(`Error executing statement: ${statement.substring(0, 100)}...`);
            throw error;
          }
        }
      }



      console.log('‚úÖ Consolidated schema created successfully from schema.sql');
    } catch (error) {
      console.error('‚ùå Error creating consolidated schema:', error.message);
      throw error;
    }
  }

  // Migration 002: Add notification system (merged version 2 and 4)
  migration_002_add_notification_system() {
    console.log('üìù Creating notification system...');

    // Add language preference to settings table
    console.log('üìù Adding language preference to settings...');
    try {
      this.db.exec(`
        ALTER TABLE settings ADD COLUMN language TEXT NOT NULL DEFAULT 'zh-CN' 
        CHECK (language IN ('zh-CN', 'en', 'ja', 'ko', 'fr', 'de', 'es'));
      `);
    } catch (error) {
      // Column might already exist, ignore error
      console.log('Language column might already exist, continuing...');
    }

    // Create notification_settings table
    this.db.exec(`
      CREATE TABLE IF NOT EXISTS notification_settings (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        user_id INTEGER NOT NULL DEFAULT 1,
        notification_type TEXT NOT NULL CHECK (
          notification_type IN (
            'renewal_reminder', 'expiration_warning', 
            'renewal_success', 'renewal_failure', 'subscription_change'
          )
        ),
        is_enabled BOOLEAN NOT NULL DEFAULT 1,
        advance_days INTEGER DEFAULT 7,
        notification_channels TEXT NOT NULL DEFAULT '["telegram"]',
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        UNIQUE(user_id, notification_type)
      );
    `);

    // Create notification_channels table
    this.db.exec(`
      CREATE TABLE IF NOT EXISTS notification_channels (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        user_id INTEGER NOT NULL DEFAULT 1,
        channel_type TEXT NOT NULL CHECK (channel_type IN ('telegram')),
        channel_config TEXT NOT NULL,
        is_active BOOLEAN NOT NULL DEFAULT 1,
        last_used_at DATETIME,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        UNIQUE(user_id, channel_type)
      );
    `);

    // Create notification_history table with simplified status (merged from version 4)
    this.db.exec(`
      CREATE TABLE IF NOT EXISTS notification_history (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        user_id INTEGER NOT NULL DEFAULT 1,
        subscription_id INTEGER NOT NULL,
        notification_type TEXT NOT NULL,
        channel_type TEXT NOT NULL,
        status TEXT NOT NULL CHECK (status IN ('sent', 'failed')),
        recipient TEXT NOT NULL,
        message_content TEXT NOT NULL,
        error_message TEXT,
        sent_at DATETIME,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        FOREIGN KEY (subscription_id) REFERENCES subscriptions (id) ON DELETE CASCADE
      );
    `);

    // Create notification_templates table
    this.db.exec(`
      CREATE TABLE IF NOT EXISTS notification_templates (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        notification_type TEXT NOT NULL,
        language TEXT NOT NULL DEFAULT 'zh-CN',
        channel_type TEXT NOT NULL,
        template_name TEXT NOT NULL,
        subject_template TEXT,
        content_template TEXT NOT NULL,
        is_active BOOLEAN NOT NULL DEFAULT 1,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        UNIQUE(notification_type, language, channel_type)
      );
    `);

    // Create indexes
    this.db.exec(`
      CREATE INDEX IF NOT EXISTS idx_notification_settings_user_type 
      ON notification_settings(user_id, notification_type);
      
      CREATE INDEX IF NOT EXISTS idx_notification_settings_enabled 
      ON notification_settings(is_enabled);
      
      CREATE INDEX IF NOT EXISTS idx_notification_channels_user_type 
      ON notification_channels(user_id, channel_type);
      
      CREATE INDEX IF NOT EXISTS idx_notification_channels_active 
      ON notification_channels(is_active);
      
      CREATE INDEX IF NOT EXISTS idx_notification_history_user 
      ON notification_history(user_id);
      
      CREATE INDEX IF NOT EXISTS idx_notification_history_subscription 
      ON notification_history(subscription_id);
      
      CREATE INDEX IF NOT EXISTS idx_notification_history_status 
      ON notification_history(status);
      
      CREATE INDEX IF NOT EXISTS idx_notification_history_created 
      ON notification_history(created_at);
      
      CREATE INDEX IF NOT EXISTS idx_notification_templates_type 
      ON notification_templates(notification_type);
      
      CREATE INDEX IF NOT EXISTS idx_notification_templates_language 
      ON notification_templates(language);
    `);

    // Insert default notification settings
    this.db.exec(`
      INSERT OR IGNORE INTO notification_settings (user_id, notification_type, is_enabled, advance_days, notification_channels) VALUES
      (1, 'renewal_reminder', 1, 7, '["telegram"]'),
      (1, 'expiration_warning', 1, 0, '["telegram"]'),
      (1, 'renewal_success', 1, 0, '["telegram"]'),
      (1, 'renewal_failure', 1, 0, '["telegram"]'),
      (1, 'subscription_change', 1, 0, '["telegram"]');
    `);

    // Insert default notification templates for Telegram
    this.db.exec(`
      INSERT OR IGNORE INTO notification_templates (notification_type, language, channel_type, template_name, content_template) VALUES
      ('renewal_reminder', 'en', 'telegram', 'default', 
        '<b>Renewal Reminder</b>
    
    üì¢ <b>{{name}}</b> is about to expire
    
    üìÖ Expiration date: {{next_billing_date}}
    üí∞ Amount: {{amount}} {{currency}}
    üí≥ Payment method: {{payment_method}}
    üìã Plan: {{plan}}
    
    Please renew in time to avoid service interruption.'),
      
      ('expiration_warning', 'en', 'telegram', 'default',
        '<b>‚ö†Ô∏è Subscription Expiration Warning</b>
    
    üì¢ <b>{{name}}</b> has expired
    
    üìÖ Expiration date: {{next_billing_date}}
    üí∞ Amount: {{amount}} {{currency}}
    üí≥ Payment method: {{payment_method}}
    üìã Plan: {{plan}}
    
    Please renew as soon as possible to restore your service.'),
      
      ('renewal_success', 'en', 'telegram', 'default',
        '<b>‚úÖ Renewal Successful</b>
    
    üì¢ <b>{{name}}</b> has been successfully renewed
    
    üí∞ Payment amount: {{amount}} {{currency}}
    üìÖ New expiration date: {{next_billing_date}}
    üí≥ Payment method: {{payment_method}}
    üìã Plan: {{plan}}
    
    Thank you for your renewal!'),
      
      ('renewal_failure', 'en', 'telegram', 'default',
        '<b>‚ùå Renewal Failed</b>
    
    üì¢ <b>{{name}}</b> renewal failed
    
    üí∞ Amount: {{amount}} {{currency}}
    üìÖ Scheduled renewal date: {{next_billing_date}}
    üí≥ Payment method: {{payment_method}}
    üìã Plan: {{plan}}
    
    Please check your payment method and renew manually.'),
      
      ('subscription_change', 'en', 'telegram', 'default',
        '<b>üìù Subscription Change</b>
    
    üì¢ <b>{{name}}</b> information has been updated
    
    üìã Plan: {{plan}}
    üí∞ Amount: {{amount}} {{currency}}
    üìÖ Next payment: {{next_billing_date}}
    üí≥ Payment method: {{payment_method}}
    
    The change has taken effect.'),
    
    -- Chinese (Simplified) templates
    ('renewal_reminder', 'zh-CN', 'telegram', 'default', 
      '<b>Áª≠ËÆ¢ÊèêÈÜí</b>

üì¢ <b>{{name}}</b> Âç≥Â∞ÜÂà∞Êúü

üìÖ Âà∞ÊúüÊó•Êúü: {{next_billing_date}}
üí∞ ÈáëÈ¢ù: {{amount}} {{currency}}
üí≥ ÊîØ‰ªòÊñπÂºè: {{payment_method}}
üìã Â•óÈ§ê: {{plan}}

ËØ∑ÂèäÊó∂Áª≠ËÆ¢‰ª•ÈÅøÂÖçÊúçÂä°‰∏≠Êñ≠„ÄÇ'),
    
    ('expiration_warning', 'zh-CN', 'telegram', 'default',
      '<b>‚ö†Ô∏è ËÆ¢ÈòÖËøáÊúüË≠¶Âëä</b>

üì¢ <b>{{name}}</b> Â∑≤ÁªèËøáÊúü

üìÖ ËøáÊúüÊó•Êúü: {{next_billing_date}}
üí∞ ÈáëÈ¢ù: {{amount}} {{currency}}
üí≥ ÊîØ‰ªòÊñπÂºè: {{payment_method}}
üìã Â•óÈ§ê: {{plan}}

ËØ∑Â∞ΩÂø´Áª≠ËÆ¢‰ª•ÊÅ¢Â§çÊúçÂä°„ÄÇ'),
    
    ('renewal_success', 'zh-CN', 'telegram', 'default',
      '<b>‚úÖ Áª≠ËÆ¢ÊàêÂäü</b>

üì¢ <b>{{name}}</b> Áª≠ËÆ¢ÊàêÂäü

üí∞ ÊîØ‰ªòÈáëÈ¢ù: {{amount}} {{currency}}
üìÖ Êñ∞ÁöÑÂà∞ÊúüÊó•Êúü: {{next_billing_date}}
üí≥ ÊîØ‰ªòÊñπÂºè: {{payment_method}}
üìã Â•óÈ§ê: {{plan}}

ÊÑüË∞¢ÊÇ®ÁöÑÁª≠ËÆ¢ÔºÅ'),
    
    ('renewal_failure', 'zh-CN', 'telegram', 'default',
      '<b>‚ùå Áª≠ËÆ¢Â§±Ë¥•</b>

üì¢ <b>{{name}}</b> Áª≠ËÆ¢Â§±Ë¥•

üí∞ ÈáëÈ¢ù: {{amount}} {{currency}}
üìÖ ËÆ°ÂàíÁª≠ËÆ¢Êó•Êúü: {{next_billing_date}}
üí≥ ÊîØ‰ªòÊñπÂºè: {{payment_method}}
üìã Â•óÈ§ê: {{plan}}

ËØ∑Ê£ÄÊü•ÊÇ®ÁöÑÊîØ‰ªòÊñπÂºèÂπ∂ÊâãÂä®Áª≠ËÆ¢„ÄÇ'),
    
    ('subscription_change', 'zh-CN', 'telegram', 'default',
      '<b>üìù ËÆ¢ÈòÖÂèòÊõ¥</b>

üì¢ <b>{{name}}</b> ‰ø°ÊÅØÂ∑≤Êõ¥Êñ∞

üìã Â•óÈ§ê: {{plan}}
üí∞ ÈáëÈ¢ù: {{amount}} {{currency}}
üìÖ ‰∏ãÊ¨°‰ªòÊ¨æ: {{next_billing_date}}
üí≥ ÊîØ‰ªòÊñπÂºè: {{payment_method}}

ÂèòÊõ¥Â∑≤ÁîüÊïà„ÄÇ');
    `);
    

    console.log('‚úÖ Notification system created successfully');
  }

  // Migration 003: Add scheduler settings table
  migration_003_add_scheduler_settings() {
    console.log('üìù Creating scheduler settings table...');

    // Create scheduler_settings table
    this.db.exec(`
      CREATE TABLE IF NOT EXISTS scheduler_settings (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        user_id INTEGER NOT NULL DEFAULT 1,
        notification_check_time TEXT NOT NULL DEFAULT '09:00',
        timezone TEXT NOT NULL DEFAULT 'Asia/Shanghai',
        is_enabled BOOLEAN NOT NULL DEFAULT 1,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        UNIQUE(user_id)
      );
    `);

    // Create trigger for scheduler_settings table
    this.db.exec(`
      CREATE TRIGGER IF NOT EXISTS scheduler_settings_updated_at
      AFTER UPDATE ON scheduler_settings
      FOR EACH ROW
      BEGIN
          UPDATE scheduler_settings SET updated_at = CURRENT_TIMESTAMP WHERE id = NEW.id;
      END;
    `);

    // Insert default scheduler settings
    this.db.exec(`
      INSERT OR IGNORE INTO scheduler_settings (user_id, notification_check_time, timezone, is_enabled)
      VALUES (1, '09:00', 'Asia/Shanghai', 1);
    `);

    console.log('‚úÖ Scheduler settings table created successfully!');
  }

  // Migration 004: Add repeat notification setting
  migration_004_add_repeat_notification_setting() {
    console.log('üìù Adding repeat notification setting...');

    // Add repeat_notification column to notification_settings table
    try {
      this.db.exec(`
        ALTER TABLE notification_settings
        ADD COLUMN repeat_notification BOOLEAN NOT NULL DEFAULT 0;
      `);
      console.log('‚úÖ Added repeat_notification column');
    } catch (error) {
      // Column might already exist, ignore error
      console.log('repeat_notification column might already exist, continuing...');
    }

    // Update renewal_reminder to allow repeat notifications by default
    this.db.exec(`
      UPDATE notification_settings
      SET repeat_notification = 1
      WHERE notification_type = 'renewal_reminder';
    `);

    console.log('‚úÖ Repeat notification setting added successfully!');
  }

  // Helper method to parse SQL statements properly
  parseSQL(sql) {
    const statements = [];
    let currentStatement = '';
    let inTrigger = false;

    const lines = sql.split('\n');

    for (const line of lines) {
      const trimmedLine = line.trim();

      if (trimmedLine === '') continue;

      // Check if we're starting a trigger
      if (trimmedLine.toUpperCase().startsWith('CREATE TRIGGER')) {
        inTrigger = true;
      }

      currentStatement += line + '\n';

      // Check if we're ending a statement
      if (trimmedLine.endsWith(';')) {
        if (inTrigger && trimmedLine.toUpperCase().includes('END;')) {
          // End of trigger
          inTrigger = false;
          statements.push(currentStatement.trim());
          currentStatement = '';
        } else if (!inTrigger) {
          // Regular statement
          statements.push(currentStatement.trim());
          currentStatement = '';
        }
      }
    }

    // Add any remaining statement
    if (currentStatement.trim()) {
      statements.push(currentStatement.trim());
    }

    return statements;
  }




  close() {
    this.db.close();
  }
}

module.exports = DatabaseMigrations;
